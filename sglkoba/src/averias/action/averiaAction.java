package averias.action;import ingreso.control.gstentrada;import ingreso.entity.entrada;import java.io.IOException;import java.math.BigDecimal;import java.sql.SQLException;import java.util.Collection;import java.util.Iterator;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import nacionalizacion.control.gstnacionalizacion_detalle;import nacionalizacion.entity.nacionalizacion_detalle;import org.apache.struts.action.Action;import org.apache.struts.action.ActionForm;import org.apache.struts.action.ActionForward;import org.apache.struts.action.ActionMapping;import org.apache.struts.action.ActionMessage;import org.apache.struts.action.ActionMessages;import util.Fecha;import util.Math;import averias.control.gstaveria;import averias.control.gstaveria_nacdet;import averias.entity.averia;import averias.form.averiaForm;import db.beanConnector;public final class averiaAction extends Action {	public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {		averiaForm _form = (averiaForm) form;		gstaveria control = new gstaveria();		String opcion = request.getParameter("opcion");		opcion = opcion == null || (opcion != null && opcion.equals("")) ? "crear" : opcion;		String mensaje = "";		String destino = "";		if (opcion.equals("activar")) {			averia entity = control.getaveria(request.getParameter("codsx"));			// UNA AVERIA SE PUEDE ACTIVAR SI NO TIENE REPARACINES:			if (control.tieneReparaciones(entity.getavecodsx())) {				mensaje = "No puede activar una averia que ya tenga reparaciones";			} else {				try {					entity.setaveestado("TRAMITE");					control.updateaveria(entity);					mensaje = "Averia Activada con exito";				} catch (SQLException e1) {					mensaje = "no se pudo activar la averia : " + e1.getMessage();					e1.printStackTrace();				}			}			averiaForm temp = new averiaForm();			temp.setopcion("update");			temp.llenar(entity);			request.setAttribute("averiaForm", temp);			destino = "averia_datos";		}		if (opcion.equals("cambiar_posicion")) {			averia entity = control.getaveria(request.getParameter("codsx"));			String aveboddest = request.getParameter("boddest");			String aveposdest = request.getParameter("posdest");			try {					entity.setaveboddest(aveboddest);					entity.setaveposdest(aveposdest);					control.updateaveria(entity);					mensaje = "Averia Actualizada con exito";				} catch (SQLException e1) {					mensaje = "No se pudo actualizar la averia : " + e1.getMessage();					e1.printStackTrace();				}						averiaForm temp = new averiaForm();			temp.setopcion("update");			temp.llenar(entity);			request.setAttribute("averiaForm", temp);			destino = "averia_datos";		}		// OPCION DE set:		if (opcion.equals("set")) {			averia entity = control.getaveria(request.getParameter("codsx"));			averiaForm temp = new averiaForm();			temp.setopcion("update");			temp.llenar(entity);			request.setAttribute("averiaForm", temp);			destino = "averia_datos";		}		// opcion de CREAR		if (opcion.equals("crear")) {			String avecompania = _form.getavecompania();			String avefecha = Fecha.getFecha();			String aveingreso = _form.getaveingreso();			String aveentrada = _form.getaveentrada();			String avetipo = _form.getavetipo();			String aveboddest = _form.getaveboddest();			String aveposdest = _form.getaveposdest();			String avecant_pleg_nac = _form.getavecant_pleg_nac();			String avecant_pleg_nnac = _form.getavecant_pleg_nnac();			String avecant_prod_nac = _form.getavecant_prod_nac();			String avecant_prod_nnac = _form.getavecant_prod_nnac();			String aveestado = "TRAMITE";			destino = "averia_datos";			beanConnector db = new beanConnector(false);			boolean resp = true;			gstentrada gent = new gstentrada(db);			gstaveria _control = new gstaveria(db);			entrada ent = gent.getentrada(aveentrada);			gstnacionalizacion_detalle gnacd = new gstnacionalizacion_detalle(db);			gstaveria_nacdet gavenacd = new gstaveria_nacdet(db);			try {				// primero miro que saldo debo restar:				BigDecimal can_pleg_nnac = new BigDecimal(avecant_pleg_nnac);				BigDecimal can_prod_nnac = new BigDecimal(avecant_prod_nnac);				BigDecimal can_pleg_nac = new BigDecimal(avecant_pleg_nac);				BigDecimal can_prod_nac = new BigDecimal(avecant_prod_nac);				BigDecimal todo_nnac = can_pleg_nnac.add(can_prod_nnac);				BigDecimal todo_nac = can_pleg_nac.add(can_prod_nac);				BigDecimal saldo_ent_nnac = new BigDecimal(ent.getentsaldosinnac());				BigDecimal saldo_ent_nac = new BigDecimal(ent.getentsaldonac());				boolean valido = true;				if (todo_nnac.compareTo(saldo_ent_nnac) > 1) {					mensaje = "No puede definir como averiado mayor cantidad al saldo NNAC";					valido = false;				}				if (todo_nac.compareTo(saldo_ent_nac) > 1) {					mensaje = "No puede definir como averiado mayor cantidad al saldo NAC";					valido = false;				}				if (valido) {					String averiado_total = Math.sumar(avecant_pleg_nac, avecant_prod_nac, avecant_pleg_nnac, avecant_prod_nnac);					// resto la cantidad para que no aparezca mas veces que las que debe ser:					ent.setentcantidad(Math.restar_bigdecimal(ent.getentcantidad(), averiado_total).toPlainString());					// fijo el saldo por cantidad:					BigDecimal nuevo_saldo_nnac = new BigDecimal(ent.getentsaldosinnac()).subtract(todo_nnac);					ent.setentsaldosinnac(nuevo_saldo_nnac.toPlainString());					BigDecimal nuevo_saldo_nac = new BigDecimal(ent.getentsaldonac()).subtract(todo_nac);					ent.setentsaldonac(nuevo_saldo_nac.toPlainString());					// fijo tambien los saldos FISICOS restando					BigDecimal nuevo_saldo_nnacf = new BigDecimal(ent.getEntsaldosinnacf()).subtract(todo_nnac);					ent.setEntsaldosinnacf(nuevo_saldo_nnacf.toPlainString());					BigDecimal nuevo_saldo_nacf = new BigDecimal(ent.getEntsaldonacf()).subtract(todo_nac);					ent.setEntsaldonacf(nuevo_saldo_nacf.toPlainString());					// fijo el saldo por peso:					// peso neto:					String peso_neto_unit = ent.getentpesoneto();					String peso_neto_averiado = Math.multiplicar(peso_neto_unit, averiado_total);					BigDecimal nuevo_saldo_peson = Math.restar_bigdecimal(ent.getentsaldopesoneto(), peso_neto_averiado);					ent.setentsaldopesoneto(nuevo_saldo_peson.toPlainString());					// peso BRUTO:					String peso_bruto_unit = ent.getentpesobruto();					String peso_bruto_averiado = Math.multiplicar(peso_bruto_unit, averiado_total);					BigDecimal nuevo_saldo_pesob = Math.restar_bigdecimal(ent.getentsaldopesobruto(), peso_bruto_averiado);					ent.setentsaldopesobruto(nuevo_saldo_pesob.toPlainString());					resp &= gent.updateentrada(ent);					resp &= _control.crearaveria(avecompania, avefecha, aveingreso, aveentrada, avetipo, aveboddest, aveposdest, avecant_pleg_nac, avecant_pleg_nnac, avecant_prod_nac, avecant_prod_nnac, avecant_pleg_nac, avecant_pleg_nnac, avecant_prod_nac, avecant_prod_nnac, aveestado, ent							.getentcodproducto(),null);					// ahora resto las nac_detalles					if (todo_nac.compareTo(BigDecimal.ZERO) != 0) {						averia ave = _control.getaveria(avecompania, avefecha, aveingreso, aveentrada);						this.averiarNacDetalles(ave.getavecodsx(), aveentrada, todo_nac.toPlainString(), gnacd, gavenacd);					}					// luego de crear la averia, creo la entrada o sumo si ya existe una entrada					/*					 * entrada ent_averia = gent.getentrada(ent.getentcodingreso(), ent.getentcodproducto(), aveboddest, aveposdest); if(ent_averia==null) { //en esa posicion / bodega no hay nada del producto, lo creo pero con SALDOS FISICOS UNICAMENTE //los saldos disponibles no para que no lo tome					 * en pedidos o packings resp &= gent.crearentrada(ent.getentcodingreso(), ent.getentcodproducto(), aveboddest, aveposdest, averiado_total, ent.getentpesoneto(), peso_neto_averiado, ent.getentpesobruto(), peso_bruto_averiado, peso_neto_averiado, peso_bruto_averiado, "0", "0",					 * ent.getEntvalor(), Math.multiplicar(ent.getEntvalor(), averiado_total), todo_nac.toPlainString(), todo_nnac.toPlainString(), ent.getEntunidad());					 * 					 * }else { //si hay algo, sumo los saldos fisicos, pero no los DISPONIBLES ent_averia.setEntsaldonacf( Math.sumar( todo_nac.toPlainString() , ent_averia.getEntsaldonacf()) ); ent_averia.setEntsaldosinnacf( Math.sumar( todo_nnac.toPlainString() , ent_averia.getEntsaldosinnacf())					 * ); ent_averia.setentsaldopesoneto(Math.sumar( peso_neto_averiado , ent_averia.getentsaldopesoneto()) ); ent_averia.setentsaldopesobruto(Math.sumar( peso_bruto_averiado , ent_averia.getentsaldopesobruto()) );					 * 					 * 					 * resp &= gent.updateentrada( ent_averia );					 */					mensaje = "averia Creado con Exito";					averia entity = _control.getaveria(avecompania, avefecha, aveingreso, aveentrada);					averiaForm temp = new averiaForm();					temp.setopcion("update");					temp.llenar(entity);					request.setAttribute("averiaForm", temp);				}				destino = "averia_datos";			} catch (SQLException e) {				e.printStackTrace();				mensaje = "No se pudo Crear el averia: <br> Revise que el saldo de la Entrada sea suficiente <br>" + e.getLocalizedMessage();				resp = false;				destino = "averia_datos";			}			if (resp)				db.commit();			else				db.rollback();			db = null;		}		// Opcion de update		if (opcion.equals("update")) {			try {				destino = "averia";				control.updateaveria(_form);				mensaje = "Averia actualizada con exito";			} catch (SQLException e) {				e.printStackTrace();				mensaje = "No se pudo Actualizar el averia: <br> " + e.getLocalizedMessage();			}		}		// Opcion de eliminar		if (opcion.equals("delete")) {			destino = "averia";			String codsx = request.getParameter("codsx");			beanConnector db = new beanConnector(false);			boolean resp = true;			try {				gstentrada gent = new gstentrada(db);				gstaveria _control = new gstaveria(db);				averia ave = _control.getaveria(codsx);				entrada ent = gent.getentrada(ave.getaveentrada());				// sumo los saldos por unidad:				BigDecimal todo_nnac = new BigDecimal(ave.getavecant_pleg_nnac()).add(new BigDecimal(ave.getavecant_prod_nnac()));				BigDecimal saldo_nnac = new BigDecimal(ent.getentsaldosinnac());				saldo_nnac = saldo_nnac.add(todo_nnac);				ent.setentsaldosinnac(saldo_nnac.toPlainString());				BigDecimal todo_nac = new BigDecimal(ave.getavecant_pleg_nac()).add(new BigDecimal(ave.getavecant_prod_nac()));				BigDecimal saldo_nac = new BigDecimal(ent.getentsaldonac());				saldo_nac = saldo_nac.add(todo_nac);				ent.setentsaldonac(saldo_nac.toPlainString());				// SUMO TAMBIEN LOS SALDOS FISICOS POR QUE LOS HABIA RESTADO				BigDecimal saldo_nnacf = new BigDecimal(ent.getEntsaldosinnacf());				saldo_nnacf = saldo_nnacf.add(todo_nnac);				ent.setEntsaldosinnacf(saldo_nnacf.toPlainString());				BigDecimal saldo_nacf = new BigDecimal(ent.getEntsaldonacf());				saldo_nacf = saldo_nacf.add(todo_nac);				ent.setEntsaldonacf(saldo_nacf.toPlainString());				// sumo los saldos por PESO que disminui en la craeacion de la averia				String averiado_total = Math.sumar(todo_nnac.toPlainString(), todo_nac.toPlainString());				// sumo la cantidad que la reste cuando cree la averia:				ent.setentcantidad(Math.sumar(ent.getentcantidad(), averiado_total));				// peso neto:				String peso_neto_unit = ent.getentpesoneto();				String peso_neto_averiado = Math.multiplicar(peso_neto_unit, averiado_total);				BigDecimal nuevo_saldo_peson = Math.sumar_bigdecimal(ent.getentsaldopesoneto(), peso_neto_averiado);				ent.setentsaldopesoneto(nuevo_saldo_peson.toPlainString());				// peso BRUTO:				String peso_bruto_unit = ent.getentpesobruto();				String peso_bruto_averiado = Math.multiplicar(peso_bruto_unit, averiado_total);				BigDecimal nuevo_saldo_pesob = Math.sumar_bigdecimal(ent.getentsaldopesobruto(), peso_bruto_averiado);				ent.setentsaldopesobruto(nuevo_saldo_pesob.toPlainString());				// ahora tengo que actualizar la entrada original con todo				resp &= gent.updateentrada(ent);				// AHORA TENGO QUE RESTAR A LA ENTRADA QUE SE CREO:				/*				 * entrada ent_averia = gent.getentrada(ent.getentcodingreso(),ent.getentcodproducto(), ave.getaveboddest(), ave.getaveposdest());				 * 				 * //resto de una los saldos fisicos que son los unicos con los que se creo:				 * 				 * ent_averia.setEntsaldonacf( Math.restar_bigdecimal( ent_averia.getEntsaldonacf() , todo_nac.toPlainString() ).toPlainString() ); ent_averia.setEntsaldosinnacf( Math.restar_bigdecimal( ent_averia.getEntsaldosinnacf(), todo_nnac.toPlainString() ).toPlainString() );				 * ent_averia.setentsaldopesoneto(Math.restar_bigdecimal( ent_averia.getentsaldopesoneto(), peso_neto_averiado ).toPlainString() ); ent_averia.setentsaldopesobruto(Math.restar_bigdecimal( ent_averia.getentsaldopesobruto() , peso_bruto_averiado ).toPlainString() );				 * ent_averia.setentcantidad( Math.restar_bigdecimal( ent_averia.getentcantidad() , averiado_total ).toPlainString() ); resp &= gent.updateentrada( ent_averia );				 */				resp &= _control.eliminar(codsx);				mensaje = "averia Eliminado con Exito";			} catch (SQLException e) {				e.printStackTrace();				mensaje = "No se pudo Eliminar el averia: <br> " + e.getLocalizedMessage();			}			if (resp)				db.commit();			else				db.rollback();		}		ActionMessages e = getErrors(request);		e.add("general", new ActionMessage(mensaje, false));		addErrors(request, e);		return mapping.findForward(destino);	}	/**	 * metodo llamado cuando la entrada que se va a mover, tiene saldo nacionalizado y tiene nacionalizacion_detalle asociadas, en este caso, hay que crear la nueva tabla reubicacion_nacdetalle en la que se registrara las nacdetalles que se restan, y a donde se suman.	 * 	 * @param entcodsx	 * @return	 */	private boolean averiarNacDetalles(String avecodsx, String entor, String cantidad, gstnacionalizacion_detalle gnacdet, gstaveria_nacdet gavnac) throws SQLException {		boolean resp = true;		Collection nacdets = gnacdet.getlistanacionalizacion_detalleByEntrada(entor);		// si no hay nacionalizaciones, no hace anda		if (nacdets.isEmpty())			return true;		Iterator itenacd = nacdets.iterator();		// por cada nacdetalle original que tengo, voy restando la cantidad		BigDecimal faltante = new BigDecimal(cantidad);		while (itenacd.hasNext() && faltante.compareTo(BigDecimal.ZERO) > 0) {			nacionalizacion_detalle nacdetor = (nacionalizacion_detalle) itenacd.next();			BigDecimal nadsaldo = new BigDecimal(nacdetor.getNadsaldo());			if (nadsaldo.compareTo(BigDecimal.ZERO) == 0)				continue;			String cant = "";			if (faltante.compareTo(nadsaldo) >= 0) {				// si el faltante es mayor, cojo todo el saldo de la nacionalizacion				cant = nadsaldo.toPlainString();				nacdetor.setNadsaldo("0");				nacdetor.setnadcantidad("0");				faltante = Math.restar_bigdecimal(faltante.toPlainString(), cant);			} else {				cant = faltante.toPlainString();				nacdetor.setNadsaldo(Math.restar_bigdecimal(nadsaldo.toPlainString(), faltante.toPlainString()).toPlainString());				nacdetor.setnadcantidad(Math.restar_bigdecimal(nacdetor.getnadcantidad(), faltante.toPlainString()).toPlainString());				faltante = BigDecimal.ZERO;			}			try {				// actualizo la nacdetalle a la que estoy restando				resp &= gnacdet.updatenacionalizacion_detalle(nacdetor);				// creo la relacion reuic_nacet para asi identificar en la reubicacion, lo que se movio con saldo				// nac producto de nacionalizaciones se mueva bien				resp &= gavnac.crearaveria_nacdet(avecodsx, nacdetor.getnadcodsx(), cant, cant);			} catch (SQLException ex) {				ex.printStackTrace();				resp = false;				// break;				throw ex;			}		}		return resp;	}}